

C++11에서 새로운 중괄호 초기화 구문인 {}가 추가됐다. ==이는 집합체 초기화뿐만 아니라 일반적으로 생성자 호출을 가능하게 하는 목적을 뒀다==. 그러나 아쉽게도 auto 변수와 결합하면 잘못된 값을 사용하기 일쑤였다. C++17에서는 향상된 초기화 규칙들이 추가됐다. 이번 예제에 C+17의 구문으로 변수를 초기화하는 올바른 방법을 명확히 알아보자.



### 예제 구현

변수는 한 번에 초기화된다. 다음은 초기화 구문을 사용한 두 가지 다른 상황이다.

- auto 자료형의 추론 없이 중괄호 초기화 구문의 사용

``` c++

// int를 초기화하는 세 가지 동일한 방법

int x1=1;
int x2{3};
int x3{1};

std::vector v1 {1,2,3}; // 1, 2, 3 세 개의 int 값을 갖는 Vector
std::vector<int> v2={1,2,3}; // 이전과 동일함
std::vecotr<int> v3{10,20}; // 각 값이 20인 int 값 10개를 갖는 Vector
```

- auto 자료형의 추론으로 중괄호 초기화 구문의 사용

``` c++
auto v {1}; // v는 int 이다.
auto w {1,2}; // 오류: 단일 요소만 auto 초기화가 허용된다(새롭게 추가된 내용이다).
auto x {1}; // x는 std::initializer_list<int>
auto y={1,2}; // y는 std::initializer_list<int>
auto z={1,2,3.0}; // 오류: 해당 자료형을 추론할 수 없다.
```


### 예제 분석

최소한 정규 자료형의 초기화에 있어서 auto 자료형 추론이 없는 중괄호 {} 연산은 딱히 놀랄 많한 것이 별로 없다. ==std::vector나 std::list 같은 컨테이너를 초기화 할 때의 중괄호 초기화는 컨테이너 클래스의 std::initializer_list 생성자와 일치하게 된다.== 이는 매우 탐욕스러운 방식으로 처리되는데, 즉 비집합체 생성자는 일치시키기가 불가능하다(비집합체 생성자는 일반적으로 초기화 목록이 허용되지 않는 생성자를 말한다).

예를 들어 std::vector는 명확한 비집합체 생성자를 제공한다. `std::vector<int> str::vector<int> v {N,value}`를 사용하면 initializer_list 생성자가 선택되는데, 이는 해당 백터를 개수(N)와 값(value) 두 가지 요소로 초기화한다. 방심하면 실수하기 쉬운 부분이니 조심하자.

일반적인 () 괄호로 호출하는 생성자와 비교했을 때 {} 연산의 매력적인 사실 중 하나는 암시적으로 자료형이 변환할 수 없다는 점이다. int x (1.2);과 int x=1.2는 x의 실수 값을 내림해 int로 변환해서 1의 값으로 초기화한다. ==반면 int x{1,2}는 명시적으로 생성자 자료형과 일치해야 하므로 컴파일 될 수 없다.==

>[!info]
> 가장 좋은 초기화 방법이 무엇이냐는 질문에 대해서는 논란의 소지가 있다.
> 중괄호 초기화 스타일을 선호하는 개발자들은 중괄호를 사용하면 매우 명쾌하게 만들 수 있다고 말한다. 즉, 변수는 생성자가 호출될 때에만 초기화되며, 해당 코드는 또다시 초기화 되지 않는 것이다. 게다가 () 괄호를 사용한 초기화는 가장 적절한 생성자를 찾아낼 뿐만 아니라 형 변환까지 처리하는 반면 {} 중괄호를 사용하면 올바른 생성자를 선택하는데 그치기 때문이다.


C++ 11에서는 변수 auto x {123};의 자료형을 정확하게 맞추는 만면 C++17에서 소개된 추가적인 규칙은 auto 자료형의 추론을 통한 초기화에 영향을 미친다. 하나의 요소를 갖는 `std::initializer_list<int>`는 원하는 대로 처리가 불가능하기 때문이다. C++17은 동일한 변수인 int로 처리할 것이다.

경험을 통해 알게 된 것들은 다음과 같다.


- auto var_name {one_element}; one_element와 같은 자료형이 되도록 var_name을 추론한다.
- auto var_name {element1,element2, ...}; 유효하지 않으며 컴파일되지 않는다.
- auto var_name={element1,element2, ...}; 목록의 모든 요소가 같은 자료형이 되도록 T로 `std::initializer_list<T>`를 추론한다.


C++17을 실수로 초기화 목록을 정의하는 위험을 크게 줄였다.

>[!info]
> C++11/C++14와 같이 다른 컴파일러로 똑같은 작업을 해보면 실제로 일부는 auto x {123};을 int로 추론하지만, 일부는 `std::initializer_list<int>`로 추론하는 걸 볼 수 있다. 이처럼 코드를 작성하면 관련한 문제가 생길 수 있다.
