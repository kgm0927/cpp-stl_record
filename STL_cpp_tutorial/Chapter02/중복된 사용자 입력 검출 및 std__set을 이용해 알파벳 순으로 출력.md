

==std::set은 매우 특이한 컨테이너다. std::map과 비슷한 역할을 하지만 오로지 키를 값으로 포함할 뿐 키-값(key-value) 쌍을 취하지는 않는다.==그래서 하나의 타입에서 다른 타입으로 값을 매핑할 때에는 거의 사용하지 않는다. 활용 사례 자체가 적은 탓일 테지만, **std::set**이라는 게 있는지조차 모르는 개발자가 많다. 대부분은 그냥 직접 코드를 작성해서 처리한다. 그러나 특히 이번에 다룰 예제에서와 같은 경우 std::set이 매우 큰 도움이 될 것이다.

이번 예제에서 다양한 요소를 취합할 예제에 std::set을 사용하는 방법을 살펴보고, 이들 요소를 필터링(filter)해 특별히 선택한 내용이 출력되게 한다.


---

### 예제 구현

이번 예제에서는 표준 입력으로부터 일련의 단어들을 보게 될 것이다. 각각의 고유한 단어를 모두 std::set 인스턴스에 입력한다. 이렇게 하면 스트림으로부터 모든 단어를 나열할 수 있다.


1. 몇 가지 다른 STL 이용하기 위해 다수의 헤더 파일을 포함시킨다.


``` c++

#include <iostream>
#include <set>
#include <string>
#include <iterator>
```

2. 입력할 코드를 줄이기 위해 std 네입스페이스의 사용을 선언한다.
``` c++
using namespace std;
```

3. 이제 실제 프로그램을 작성할 준비가 됐다. 문자열을 보관하는 std::set 인스턴스를 생성하도록 메인 함수에서 시작한다.

``` c++
int main(){

    set<string> s;
```

4. 그런 다음 사용자 입력을 얻는다. 표준 입력으로부터 읽는데, istream_iterator를 사용하면 편리하다.

``` c++
    istream_iterator<string> it {cin};

    istream_iterator<string> end;
```

5. 사용자 입력을 나타내는 begin과 end 반복자를 쌍을 가져서 std::inserter를 이용해 set을 채울 수 있다. 

``` c++
    copy(it,end,inserter(s,s.end()));
```

6. 이게 끝이다. 표준 입력에 어떤 고유한 단어가 있는지 확인하기 위해 해당 set의 내용물을 출력한다.

``` c++
    for (const auto word : s)
    {
        cout<<word<<", ";
    }

    cout<<'\n';
```


7. 컴파일하고 다음 입력값으로 프로그램을 실행한다. 선행 입력으로부터 다음의 출력을 얻는다. 그러면 고유한 단어들이 다음과 같이 알파벳순으로 나열된다.

``` c++
PS C:\C-language\cpp_STL\Chapter02> echo "a a a b c foobar foo bar bar" | ./Chapter02_9       
a, b, bar, c, foo, foobar,
```

---
### 예제 분석

이 예제에는 흥미로운 부분이 두 가지 있다. 첫 번째는 std::istream_iterator를 이용해 사용자 입력에 접근하는 것이고, 두 번째는 std::inserter 인스턴스로 감싼 다음 std::copy 알고리즘을 이용해 std::set 인스턴스와 합치는 것이다. 입력 내용을 토큰화해서 알파벳순으로 정렬하고, 여기서 또 중복된 내용을 제거하는 모든 과정을 코드 라인 한 줄로 처리할 수 있다는 것이 매루 인상적일 것이다.


- **istream_iterator**

이 클래스는 이번 예제와 같이 스트림으로부터 대량의 같은 타입 데이터를 처리해야 할 경우에 매우 흥미로운 역할을 한다. 입력된 내용 전체를 단어별로 하나씩 분석해 std::string 인스턴스의 형태로 set에 입력했다.

std::istream_iterator는 한 개의 템플릿 파라미터를 받는다. 이것이 원하는 입력 타입이다. std::string을 선택한 이유는 여기서 단어들이 텍스트일 것으로 추정했기 때문이지만, 예를 부동소수점 숫자와 같은 다른 형태일 수도 있다. 사실 cin>>var;을 작성할 수 있는 형태라면 어떤 것이든 가능하다. 생성자는 istream 인스턴스를 받는다. 이때 표준 입력은 전역 입력 스트림 객체인 std::cin으로 나타내며, 여기서는 허용 가능한 istream 파라미터다.

``` c++
istream_iterator<string> it {cin};
```

인스턴스로 만든 입력 스트림 반복자 it는 두 가지를 할 수 있다. 먼저 반복자가 it가 참조 (`*it`)될 때에는 현재의 입력 심볼을 입력한다. `std::string`에 해당 템플릿 파라미터로 반복자를 입력하면 해당 심볼은 한 단어를 포함한 문자열이 될 것이다. 반복자 it가 증가(++it)할 때에는 다음 단어로 건너뛰게 되며, 이는 다시 참조를 통해 접근할 수 있다.

여기서 잠깐, 반복자를 다시 참조하기 전에 매번 증가 이후에 조심해야 할 것이 있다. ==표준 입력이 비어있을 대 반복자는 다시 참조해서는 안 된다.== 대신 반복자를 참조한 반복문을 종료해야 각각의 단어를 얻을 수 있다. 조건문의 중단은 반복자가 무효하다는 것을 알게 되며, end 반복자와 비교해 가능하다. `it==end`이면 입력의 가장 마지막을 지난 것이다.

`std::istream_iterator` 인스턴스를 파라미터가 없는 표준 생성자로 생성해 end 반복자를 생성한다. 이 반복자는 각각의 반복 과정에서 중단 상태의 역할을 하는 비교 대상이 된다.

``` c++
istream_iterator<string> end;
```

`std::cin`이 빈값으로 실행되면 곧바로 it 반복자 인스턴스가 이를 감지하고 true를 반환하는 end를 비교를 할 것이다.


- **std::insertor**

`std::copy` 호출에 입력 반복자로 it과 end 쌍을 이용했다. 세 번째 파라미터는 출력 반복자여야 한다. 이를 위해서는 단순히 s.begin()이나 s.end()를 사용할 수 없다. 비어있는 세트에서는 둘 다 똑같으므로, 읽어오는 경우든 할당하는 경우든 참조하는 것초자 불가능하다.

바로 여기에 std::insertor가 유용하게 사용된다. `std::insertor` 함수는 `std::insert_iterator`를 반환하는는데, 이는 반복자와 비슷한 역할을 하지만 일반적인 반복자와는 조금 다른 기능을 한다. 해당 반복자를 증가시켜도 아무것도 하지 않는다. ==그러나 참조를 해서 여기에 뭔가 할당하면 연관된 컨테이너를 받아 해당 값을 새로운 요소로 삽입한다.==


`std::insertor`를 통해 `std::insert_iterator`를 객체로 만들 때 두 개의 파라미터가 필요하다.

``` c++
auto insert_it=insertor(s,s.end());
```

s는 여기서 사용할 세트이고, s.end()는 새로운 요소가 삽입될 위치를 가리키는 반복자다. 빈 세트에서 시작할 때에는 s.begin()이 좀 더 적합할 것이다. 벡터나 리스트와 같은 다른 데이터 구조체에 사용할 때에는 삽입 반복자가 새 요소를 어디에 삽입할지를 정의하는 이 두 번째 파라미터가 매우 중요하다.



- **합치기**

가장 마지막에는 `std::copy`를 호출해 모든 처리가 이루어진다.

``` c++
copy(input_iterator_begin,input_iterator_end, insert_iterator);
```

이 함수 호출들은 입력 반복자를 통해 std::cin으로부터 다음 단어 토긐을 이끌어낸 std::set에 넣는다. 그런 다음 두 반복자를 모두 증가시켜 해당 입력 반복자가 edn 반복자와 같은지 확인한다. 같지 않을 경우 표준 입력에 아직 다른 단어가 남아있으므로 비교 동작을 반복한다.

중복된 단어는 자동으로 누락시킨다. 세트가 이미 특정 단어를 포함하고 있는 경우 이를 추가하려 해도 아무 일이 일어나지 않는다. `std::multiset`은 중복 단어를 수락하는 것과 비교해 매우 다르다는 것을 알 수 있다.
