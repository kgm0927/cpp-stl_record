

STL에서 가장 폭넓게 사용되는 컨테이너는 std::vector일 것이다. 이 컨테이너는 데이터를 일련의 배열처럼 다루며, 다양한 편의성을 추가할 수 있기 때문이다. 그러나 벡터로 접근할 때 올바른 방법을 사용하지 않으면 위험할 수 있다. 벡터 하나에 100개의 요소가 담겨있고, 코드가 실수로 인덱스 123의 요소에 접근하고자 한다면 좋지 않는 결과가 나올 것은 뻔하다. 

이러한 처리는 명백히 오류이므로 프로그램이 크래시가 발생한다면 차라리 가장 나은 경우다. 멈추지 않고 계속 돌아가는 경우 프로그램이 종종 이상한 행동을 보일 것이다. 그리고 이러면 보통 크래시가 발생하는 것보다 훨씬 더 골치 아픈 일이 발생하기 마련이다. 경험이 많은 프로그래머라면 벡터 인덱스에 직접 접근하기 전에 좀 더 꼼꼼히 확인하고 진행할 것이다. 이러한 확인은 코드의 가독성을 높이지는 않는다. ==그리고 std::vector에는 이미 범위 검사가 포함돼 있다는 것을 대부분 모르고 있다.==


### 예제 구현

이번 예제에서는 std::vector에 접근하는 두 가지 방법을 알아보고, 가독성을 떨어뜨리지 않고 좀 더 안전한 프로그램에 이를 어떻게 활용할지 알아본다.


1. 필요한 모든 헤더 파일을 포함한 다음, 벡터를 123 값으로 1000번 채운다.
``` c++

#include <iostream>
#include <vector>

  

using namespace std;

int main(){

    const size_t container_size{1000};
    vector<int> v (container_size,123);
```


2. 이제 `[]` 연산자를 이용해 범위 밖의 벡터에 접근한다.

``` c++
    cout<<"Out of range element value:"<<v[container_size+10]<<'\n';
```

3. 그런 다음 at 함수를 이용해 범위 밖으로 접근한다.
``` c++
    cout<<"Out of range element value: "<<v.at(container_size+10)<<'\n';
```


4. 프로그램을 실행시켜 어떤 결과가 나오는지 확인해보자. 오류 메시지는 GCC 메시지다. 다른 컴파일러는 이와 똑같지는 않지만 비슷한 오류 메시지를 출력한다. 첫 번째 코드는 다소 특이한 방식으로 성공할 것이다. ==프로그램이 크래시가 발생하지는 않지만 123과는 전혀 다른 값이 나온다. 또 다른 코드의 출력줄은 확인할 수가 없다.== 분명 전체 프로그램이 크래시가 발생했을 것이 뻔하기 때문이다. 범위를 벗어난 접근이 일개 사고였다면 일찌감치 잡아냈을 것이다.

``` shell
PS C:\C-language\cpp_STL\Chapter02> ./Chapter02_3
Out of range element value:0
Out of range element value: terminate called after throwing an instance of 'std::out_of_range'
  what():  vector::_M_range_check: __n (which is 1010) >= this->size() (which is 1000)
```

---
### 예제 분석


`std::vector`는 `[]` 연산자와 at 함수를 제공한다. 이 둘이 기본적으로 하는 일은 같다. ==그러나 at 함수는 범위 검사를 추가로 해서 해당 벡터(vector)의 범위를 초과할 경우 예외를 던진하는 점이 다르다.== 지금 예제와 같은 상황에서는 유용하지만 프로그램을 약간 느리게 만들기도 한다.

특히 인덱스로 이뤄진 숫자를 이용한 계산을 할 때는 굉장히 빠른 속도가 중요하므로 `[]`인덱스 접근 방식을 이용하는 것이 좋다. 그러나 대부분의 다른 경우에는 at 함수를 이용하면 특별한 성능 방해 없이 버그를 잡아내는 데 많은 도움이 된다.

>[!tip]
>이러한 예제는 at 함수를 기본 설정으로 해 놓고 연습하면 좋다. 결과로 얻은 코드는 매우 느리긴 해도 버그가 없다는 것이 입증됐으므로, 반드시 높은 성능을  내야 하는 영역에 `[]` 연산자를 사용하면 된다.


---
### 부연 설명

물론 전체 프로그램에 크래시가 발생하는 대신에 범위를 넘어선 접근에 대해 처리할 수도 있다. 이를 위해서 at 함수로 던져진 예외를 잡아내야 한다. 이러한 예외를 찾아내는 과정은 매우 간단하다. at 호출을 try 코드로 둘러싼 다음 catch 코드에서 오류 처리를 정의해주면 된다.


``` c++
  try{
    std::cout<<"Out of range element value:"
    <<v.at(container_size+10)<<endl;

  

  }catch(const std::out_of_range &e){
    cout<<"Oooops, out of range access detected: "<<e.what()<<endl;
  }
```


>[!info]
>std::array 또한 at 함수를 제공한다.


---
- [[std__vector에서 삭제-제거 관용구 사용]]
- [[std__vector 인스턴스의 정렬 유지]]
- 