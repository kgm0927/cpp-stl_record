

2장에서 다루는 내용은 다음과 같다.

- std::vector에서 삭제-제거 관용구 사용
- $O(1)$ 시간으로 정렬하지 않은 std::vector의 요소 삭제
- std::vector 인스턴스에 빠르고 안전하게 접근
- std::vector 인스턴스의 정렬 유지
- 필요한 조건을 걸어 효율적으로 std::map에 요소 삽입
- std::map::insert의 새로운 삽입 판별 시맨틱(semantic) 이해
- 중복된 사용자 입력 및 검출 std::set을 이용해 알파벳순으로 출력
- std::stack으로 간단한 RPN 계산기 구현
- std::map을 이용해 단어 빈도수 카운터 구현
- std::set을 이용해 긴 텍스트 문장을 찾는 문제 헬퍼 도구 구현
- std::priority_queue를 이용해 할 일 목록 구현

---

# 소개

C++ 표준 라이브러리는 다양한 종류의 표준 컨테이너가 들어있다. 한 컨테이너에는 반드시 그에 해당하는 데이터나 객체 모음이 포함돼 있다. 컨테이너의 좋은 점은 어떤 객체에든 사용할 수 있기 때문에 개인의 작업 환경에 따라 적절한 컨테이너만 고르면 된다는 점이다. STL은 스택(stack), 자동으로 증가되는 벡터(vector), 맵(map) 등을 제공한다. 이 덕분에 개발자는 전체 시스템을 다시 만들 필요 없이 애플리케이션 개발에만 집중할 수 있다. 따라서 C++ 프로그래머라면 모든 컨테이너를 속속들이 잘 알고 있는 것이 중요하다.


STL이 제공하는 모든 컨테이너는 다음과 같은 유형으로 정리할 수 있다.

- 인접 저장소
- 리스트 저장소(List trees)
- 검색 트리(Search trees)
- 해시 테이블(Hash tables)
- 컨테이너 어댑터(Container adapters)


### 인접 저장소

객체를 저장하는 가장 간단한 방법은 하나의 큰 메모리 영역에 모둔 함께 넣어두는 것이다. 이런 메모리에는 O(1) 시간의 **랜덤 액세스**(random access) 방식으로 접근할 수 있다.

가장 쉬운 방법은 일반적인 C 스타일의 배열의 감싸는 `std::array`를 이용하는 것이다. 이 방법은 보통 일반적인 C 스타일 배열보다 더 자주 쓰이는데, ==실행 시간 비용이 없을 뿐만 아니라 사용하기도 편하고 안전하기 때문이다.== C 스타일 배열과 같이 std::array를 생성하면 고정(fixed)크기를 갖는다.

std::vector는 배열 형태의 저장소가 필요할 때 다양한 크기로 작동하며, 힙(heap) 메모리를 이용해 객체를 저장한다. 객체가 현재 크기를 넘어 해당 벡터의 한계에 다다르면 자동으로 새로 배당된 메모리 영역으로 옮긴 후 기존 메모리 영역은 삭제한다. 그 뿐만 아니라 기존 요소 사시에 새로운 요소를 추가하면 그에 맞춰 기존 요소를 앞뒤로 이동시키기도 한다. 반대로 중간쯤에 있는 요소를 삭제하면 다른 객체를 함께 이동시켜 벡터 클래스가 자동으로 빈 공간을 없앤다.

std::vector 앞뒤로 많은 객체를 한꺼번에 추가하거나 삭제하면 공간 확보를 위해 새로운 메모리 할당이 이뤄지고 이는 곧 객체 이동에 큰 비용이 소요된다는 것을 의미하는데, std::deque는 균형을 유지하는 재미있는 방식을 제공한다. 크기가 고정된 인접 메모리 영역에 해당 객체를 저장하지만, 이 메모리 영역은 각각 따로 독립된 형태를 띠고 있다. 이러한 방식을 이용하면 매우 간단하고 빠르고 데크(deque)를 증가시킬 수 있는데, 기존 메모리 영역에 있는 객체는 그대로 두고 컨테이너의 앞이나 뒤에 새로운 영역을 할당하기 때문이다. 데크는 양방향 입출력(double-ended queue)을 뜻한다.


### 리스트 저장소

`std::list`는 고전적인 형태의 이중 연결 리스트 그 이상 이하도 아니다. 오직 단방향 목록 순화가 필요할 때만 `std::forward_list`가 공간 및 유지 보수 복잡성 두 가지 성능 기준에 더 잘 부합하는데, 리스트 요소의 포인터를 한 방향으로만 유지하기 때문이다. 리스트는 오직 $O(n)$시간으로 선형 횡단만 할 수 있다. 즉, 특정 위치에 요소를 삽입하거나 제거하는 것은 $O(1)$ 시간으로 가능하다.


### 검색 트리

객체가 순서대로 돼 있어 `<`와 같은 수학 관계식으로 정렬할 수 있다면 검색 트리(Search trees)를 이용할 수 있다. 이름에서 알 수 있듯 검색 트리는 검색 기(search key)를 이용해 특정 요소를 검색하며, `O(log(n))` 검색 시간을 허용한다.

STL은 이러한 검색 트리를 다양한 형태로 제공하는데, 그중 고유한 객체를 트리 구조로 정렬하는 std::set이 가장 단순한 형태다.


std::map은 이와는 조금 다르게 두 개가 한 쌍으로 이뤄진 데이터를 저장한다. 이때 한 쌍은 키(key)와 값(value)으로 구성돼 있다. 검색 트리가 요소들을 정렬하기 위해 키를 사용하는데, `std::map`을 연관 컨테이너로 사용하도록 활성화한다. `std::set`의 경우에서와 같이 모든 키 요소는 전체 트리에서만 단 한 번만 존재한다.


`std::multiset`과 `std::multimap`은 키 객체의 고유성을 제거해 특수화돼 있다.


### 해시 테이블


연관 컨테이너와 관련해서 얘기할 때, 꼭 검색 트리가 유일한 구현 방법은 아니다. 해시테이블(hash tables)을 이용하면 요소를 `O(1)` 시간에 찾을 수 있는데, ==요소들의 순서는 무시하기 때문에 일정한 정렬 기준으로 순회할 수 없다.== 해시 테이블의 크기는 사용자가 직접 조정할 수 있고, 해시 기능 또한 개별적으로 선택할 수 있다. 그에 따라 공간 소비 대비 성능이 좌우되므로 어떤 크기와 기능을 선택하는지가 매우 중요하다.


`std::unordered_set`이나 `std::unordered_map`에는 std::set 이나 std::map과 교환해서 사용할 수 있을 정도로 비슷한 다양한 인터페이스가 있다.

검색 트리 구현과 마찬가지, 두 컨테이너 모두의 한 싸의 데이터를 갖는다. `std::unordered_set`과 `std::unordered_map`은 둘 다 객체와 키의 고유성을 제거해서 동일한 키 하나로 두 개 이상의 요소를 저장할 수 있게 한다.


### 컨테이너 어뎁터

데이터를 저장하고 방법에는 배열, 리스트, 트리, 해시 테이블 외에도 스택, 큐(queue) 등 다른 방법도 있다. 더욱 기본적인 것을 사용해 좀 더 세련된 구조체를 구현할 수 있는데, STL를 사용해 std::stack, std::queue, std::priority_queue와 같은 컨테이너 어댑터(Container adapter)의 형태로 구현할 수 있다.

매력점인 점은, 데이터 구조체가 필요할 때마다 이 중에서 필요한 어댑터를 고르기만 하면 된다는 점이다. 그리고 선택한 어댑터가 원하는 성능을 구현하지 못할 때는 간단히 템플릿 파리미터(template parameter)를 변경해 다른 컨테이너 구현을 사용하면 된다. 즉, 예를 들어 `std::stack` 인스턴스 구현을 `std::vector`에서 `std::deque`로 바꿔주면 된다.



---
- [[std__vector에서 삭제-제거 관용구 사용]]
- [[O(1) 시간으로 정렬되지 않은 std__vector의 요소 삭제]]
- [[std__vector 인스턴스에 빠르고 안전하게 접근]]
- [[std__vector 인스턴스의 정렬 유지]]
- [[필요한 조건을 걸어 효율적으로 std__map에 요소 삽입]]
- [[std__map__insert의 새로운 삽입 판별 시맨틱 이해]]
- [[std__map 요소의 키를 효율적으로 변경]]
- [[std__unordered_map을 사용자 지정 타입으로 사용]]
- [[중복된 사용자 입력 검출 및 std__set을 이용해 알파벳 순으로 출력]]
- [[std__stack으로 간단한 RPN 계산기 구현]]
- [[std__map을 통해 단어 빈도수 카운터 구현]]
- [[std__multimap을 이용해 긴 문장을 찾는 문체 헬퍼 도구 구현]]
- 


