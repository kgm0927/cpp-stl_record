

std::map에서 특정 요소를 찾는 것은 `O(log(n))`시간이 소요된다. 이는 새로운 요소를 삽입할 때 찾는 것과 같다. 가장 단순하게 M의 새로운 요소 삽입은 `O(M*log(n))` 시간이 소요될 것이다.

좀 더 효율적으로 하려면 std::map 삽입 함수가 선택적으로 삽입 판별 파라미터를 받게 한다. ==기본적으로 반복자인 삽입 판별은 삽입될 요소의 가까운 예측 위치를 가리킨다.== 해당 판별이 올바르면 분할 상환된 O(1) 삽입 시간을 갖게 된다.

---
# 예제 구현

이번 예제에서는 std::map에 여러 개의 요소를 삽입하고 이에 해당하는 삽입 판별을 이용해 검색 횟수를 보여줄 것이다.


1. 문자열을 숫자로 매핑할 것이므로 std::map과 std::string을 위해 다음과 같은 헤더 파일을 포함시킨다.


``` c++
#include <iostream>

#include <map>

#include <string>
```

2. 다음으로 문자들로 된 해당 맵을 인스턴스로 만든다.

``` c++
int main(){

    std::map<std::string,size_t> m {{"b",1},{"c",2},{"d",3}};
```

3. 이제 여러 요소를 삽입하고, 각 요소에 삽입 판별을 사용할 것이다. 처음에는 판별이 없으므로 맵의 end 반복자를 가리키는 가장 첫 번째 삽입을 처리한다.

``` c++
    auto insert_it(std::end(m));
```


4. ==이제 주어진 반복자 판별을 항상 이용해 거꾸로 된 알파벳순으로 요소를 삽입할 것이다. 그러고 난 후 이를 삽입 함수의 반환값으로 다시 초기화한다.== 다음 요소는 판별 바로 직전에 삽입된다.

``` c++

  for (const auto &s: {"z","y","x","w"})
    {
        insert_it=m.insert(insert_it,{s,1});
    }
```

5. 단순히 처리되지 않은 경우를 보여주기 위해 맵의 가장 왼쪽에 위치할 문자열을 삽입할 때 완전히 잘못된 판별을 부여해 맵의 가장 오른쪽을 가리키게 해 보자.

``` c++
    m.insert(std::end(m),{"a",1});
```


6. 끝으로 맵의 내용물을 출력해본다.

``` c++
    for (const auto &[key,value] : m)

    {

        std::cout<<"\""<<key<<"\":"<<value<<", ";

    }

    std::cout<<'\n';
```

7. 이를 컴파일하고 실행하면 다음과 같은 결과물이 나온다. 맵 정렬이 여전히 올바른 것을 보면 잘못된 삽입 판별이 그리 큰 영향을 끼치지 않는다는 것을 알 수 있다.
``` shell

PS C:\C-language\cpp_STL\Chapter02> ./Chapter02_6
"a":1, "b":1, "c":2, "d":3, "w":1, "x":1, "y":1, "z":1, 
```

---
### 예제 분석

이번 예제에서 보여준 일반적인 맵 삽입과 다른 점은 판별 반복자가 추가됐다는 점이다. 또한 올바른 판별과 잘못된 판별에 대해서도 다뤘다.

올바른 판별은 기존 요소를 가리킨다. 즉, 삽입될 요소보다 큰 요소를 가리킴으로써 새로 삽입되는 키는 판별 바로 직전에 처리된다. 이와 같이 사용자가 삽입할 때 제공한 판별이 적용되지 않는 경우 삽입 함수가 최적화되지 않는 삽입으로 돌아가 다시 `O(log(n))` 성능을 띄게 된다.


앞서 실행한 첫 번째 삽입에서는 시작할 판별로서 별달리 더 나은 방법이 없었으므로 맵의 end 반복자를 구했다. 트리에 'z'를 배치한 후 'y'를 배치하면 'z'의 바로 앞에 올바른 판별이 될 새로운 요소를 삽입한다는 것을 알게 됐다. 이와 같은 방식으로 'y'를 삽입한 후 'x'를 삽입하는 경우에도 똑같이 적용된다. ==즉, 이는 다음 삽입을 위해 마지막 삽입에 의해 반환된 반복자를 사용할 수 있는 이유다.==


>[!tip]
> C++11 이번 버전에서는 삽입 판별이 새롭게 삽입된 요소의 위치보다 먼저 가리킬 때 올바른 것으로 처리된다는 점에서 주의하자.


---
### 부연 설명

재미있는 것은 잘못된 판별이라 할지라도 맵 안에 있는 요소의 순서를 방해하거나 파괴하지 않다는 점이다. 이게 어떻게 가능할까? 그리고 삽입 처리 시간이 분할 상환된 `O(1)`이라는 것은 무슨 의미일까?

std::map은 주로 이진 검색 트리를 이용해 실행된다. 새로운 키를 검색 트리에 입력하면 다른 노드와 위에서부터 차례대로 비교한다. 새로운 키가 특정 노드보다 크거나 작으면 검색 알고리즘이 왼쪽이나 오른쪽으로 갈라져 다음 차례 노드로 간다. 이 과정에서 검색 알고리즘이 현재 트리에서 가장 아래에 도달하면 그곳에 해당 키로 새로운 노드를 배치한다. 이러한 과정은 트리의 균형을 깨트릴 수 있기 때문에 나중이 유지 보수 차원에서 균형 재배치 알고리즘으로 수정해줘야 한다. 

==서로 직접 맞닿아 이웃하고 잇는 키 값을 트리에 삽입할 때에는 트리 안에서도 붙여 삽입하는 경우가 많다.== 예를 들어 정수 1과 2 사이 다른 정수가 올 수 없어 이웃하고 있는 경우가 이에 해당한다. 특정 키와 여기에 동반하는 판별이 참인지 거짓인지 쉽게 확인할 수 있다. 또한 이 경우 검색 알고리즘을 생략할 수 있어 실행 시간을 눈에 띄게 줄일 수 있다. 나중에 **재균형 알고리즘**을 실행하긴 해야 한다. 이러한 최적화가 항상 가능한 것은 아니지만 종종 이러한 방법으로 평균 수행 성능을 얻을 수 있다.

여러 번의 삽입 후 결과적으로 발생한 실행 시간의 복잡성을 나타낼 수 있는데, 이를 **상환 시간 복잡성**(amortized complexity)라고 한다.

[그림]

삽입 판별이 거짓인 경우 삽입 함수는 그냥 해당 판별을 무시하고 검색 알고리즘을 처음부터 다시 실행한다. 이 과정은 올바르게 작동하긴 하지만 매우 느리다.