

std::vector 한가운데서 요소 제거는 O(n)의 시간이 소요된다. 요소를 제거하고 나 결과로 생긴 공백 뒷부분의 모든 요소를 하나씩 왼쪽으로 옮겨서 채워 넣어야 하기 때문이다.

요소들이 복잡하거나 큰 경우라면 이렇게 요소를 옮기는 작업 비용이 매우 높을 것이다. 원래의 순서를 지키는 것이 중요하지 않은 경우 작업 과정을 최적화할 수 있다.

이번 예제를 통해 이를 어떻게 구현하는지 살펴보자.


---
### 예제 구현

이번 예제에서는 std::vector 인스턴스를 숫자로 채우고 빠르게 제거하는 함수를 구현해 $O(1)$ 시간으로 벡터에서 특정 요소를 제거해보자.

1. 먼저 필요한 헤더 파일을 포함시킨다.

``` c++
#include <iostream>

#include <vector>

#include <algorithm>
```

2. 그런 다음에 숫자들의 벡터를 인스턴스로 만드는 메인 함수를 정의한다.

``` c++
int main(){

    std::vector<int> v{123,456,789,100,200};
```

3. 다음으로 인덱스(index) 2의 값을 삭제한다(인덱스 2는 0부터 증가된 숫자이므로 여기서는 세 번째인 789에 해당한다). 이 작업에 사용할 함수는 아직 구현되지 않았다. 함수 구현은 나중에 나오는 예제에서 처리할 것이다. 그런 다음, 벡터의 내용물을 처리한다.

``` c++
   quick_remove_at(v,2);

    for (int i : v)
    {
        std::cout<<i<<", ";
    }

    std::cout<<"\n";
```


4. 이제 또 다른 요소를 제거해보자. 이번에는 123 값을 지우려고 하지만 해당 인덱스는 모를 경우를 가정해보자. 따라서 std::find 함수를 이용해 범위(벡터)와 해당 값을 받은 후 위치를 검색할 것이다. 그러면 123 값을 가리키는 반복자가 반환된다. 다시 한 번 quick_remove_at 함수를 똑같이 이용하는데, ==이번에는 반복자를 받았던 이전의 것을 오버로드(overload)하게 된다. 이 또한 아직 구현하지 않았다.==


``` c++
  

    quick_remove_at(v,std::find(std::begin(v),std::end(v),123));
    for (int i : v)
    {
        std::cout<<i<<", ";
   }
    std::cout<<'\n';
```


5. 두 개의 quick_remove_at 함수를 제외한 모든 작업이 끝났다. 이제 이 두 함수를 구현해보자(이 두 함수는 메인 함수 이전에 선언해야 하므로 해당 위치에 정의하자). ==두 함수 모두 무언가의 벡터를 참조하므로(여기서는 해당 int 값), 사용자가 어떤 벡터를 선택할 것인지에 따라 달라진다.== T 값의 벡터가 된다. 우리가 다루는 첫 번째 quick_remove_at 함수는 인덱스 값, 즉 숫자를 받으므로 같은 인터페이스가 된다.


``` c++
template <typename T>

void quick_remove_at(std::vector<T> &v,std::size_t idx){
```


6. 이제 가장 중요한 부분이 나왔다. 어떻게 하면 다른 요소들을 최소한으로 이동시키면서 원하는 요소를 빠르게 제거할 수 있을까? ==가장 먼저 벡터의 가장 마지막 값을 받아 삭제하려는 요소에 덮어쓰게 한다.== 그런 다음, ==벡터의 가장 마지막 요소를 제거한다.== 두 단계로 끝난다. 해당 코드를 간단한 무결성 검사로 감쌀 것이다. 인덱스 값이 벡터 범위에서 명확하게 벗어나 있다면 별다른 처리를 하지 않는다. 그렇지 않으면 코드에서 빈 벡터에 대해 크래시가 발생한다.

``` c++

 if (idx<v.size())
    {
        v[idx]=std::move(v.back());
        v.pop_back();
    }
```


7. 또 다른 quick_remove_at 함수도 비슷한 방법으로 적용한다. 이번에는 숫자 인덱스를 받는 대신 `std::vector<T>`의 반복자를 받는다. 기본적으로 해당 타입을 얻어내는 것은 그리 복잡하지 않는데, STL 컨테이너가 이러한 타입을 이미 정의하기 때문이다.

``` c++
template <typename T>

void quick_remove_at(std::vector<T> &v,typename std::vector<T>::iterator it){
```


8. 이제 반복자가 가리키는 값에 접근할 것이다. 첫 번째 함수에서 했던 것과 같이 벡터의 가장 마지막 요소를 여기에 덮어쓰게 한다. ==이번에는 숫자 인덱스가 아니라 반복자를 다루기 때문에 조금 다른 방법으로 반복자가 올바른 위치에 있는지 확인한다.== 해당 반복자가 **end** 위치를 가리킬 경우 참조를 허용하지 않는다.

``` c++
    if(it!=std::end(v)){
```


9. if 코드 내에서 이전과 같은 처리를 한다. 즉, 제거할 요소를 마지막 위치의 요소 값으로 덮어쓴 다음 벡터의 가장 마지막 요소를 삭제한다.

``` c++

     *it=std::move(v.back());
        v.pop_back();
```


10. 이게 처리 과정의 전부다. 프로그램을 컴파일하고 실행시키면 다음과 같이 출력된다.

``` c++
PS C:\C-language\cpp_STL\Chapter02> ./Chapter02_2
123, 456, 200, 100,
100, 456, 200,

```


---

### 예제 분석

quick_remove_at 함수는 다른 요소를 최소한으로 건드리면서 필요한 요소만 빠르게 제거한다. 이 함수의 처리 방식은 매우 기발하다. ==실제 요소를 벡터의 마지막 요소로 교체해 제거한다.== 마지막 요소는 실제 선택된 요소와 아무 관련이 없지만, 여기서 매우 특별한 의미를 가진다. 마지막 요소를 제거하는 과정은 비용이 아주 적게 든다는 점이다! 즉, 벡터의 크기만 한 자리 줄이면 되는 것이다. 이 단계에서는 아무 요소도 제거하지 않는다. 다음에 나오는 다이어그램을 보면 이해가 더 쉬울 것이다.

[그림]


이번 예제의 두 단계 모두 다음과 같은 코드를 사용한다.

``` c++
  v[idx]=std::move(v.back());
        v.pop_back();
```

그리고 다음은 반복자 코드로서 앞의 코드와 거의 비슷하다.

``` c++
     *it=std::move(v.back());
        v.pop_back();
```

따지고 보면 선택한 요소와 마지막 요소를 맞바꾼 것이다. ==그런데 사용한 코드를 보면 요소를 교환하는 것이 아니라 마지막 요소를 덮어씌웠다.== 왜 그런 걸까? 요소를 교환하게 되면 선택한 요소를 임시 변수에 저장하고, 마지막 요소를 선택한 요소로 옮겨준 후 임시 값을 마지막 자리에 다시 넣어줘야 한다. 이 마지막 요소를 바로 지울 것이기 때문에 이러한 일련의 과정은 불필요해 보인다.

그래서 교환 방식은 불필요하며, 한쪽으로 덮어쓰는 게 좋은 방법이다. 지금까지 봐온 것처럼 여기에 간단히 `*it=v.back()` 함수를 사용하면 될 거라고 생각할 수 있다. 

물론 가능하다. 그러나 문자열이 큰 경우 이것을 각각의 요소로, 또는 다른 벡터나 맵에 일일이 저장하는 과정은 매우 높은 비용이 들 것이다. 중간에 있는 std::move 호출은 그저 최적화를 위해서이다. 문자열의 경우 내부적으로 힙 메모리에서 큰 문자열을 가리킨다. 이를 복사할 필요는 없다. 대신 하나의 문자열을 이동시킬 대 다른 문자열 데이터의 한 지점에 목적지를 지정한다. 이동하는 원본 문자열은 온전히 사용하지 않는 상태로 두는데, 결국 제거할 것이므로 큰 상관없다.


---
- [[std__vector에서 삭제-제거 관용구 사용]]
- [[std__vector 인스턴스에 빠르고 안전하게 접근]]
