

많은 초보 C++ 프로그래머가 std::vector에 대해 배우지만, 대부분 자동으로 배열을 증가시키는 기능까지만 사용하는데 그친다. 나중에는 검색해서 요소 제거와 같이 일부 특정 기능을 사용하는 것이 전부인 경우가 많다. 이렇게 표면적으로만 사용하면 실제 STL 컨테이너를 이용하는 것이 코드를 깔끔하고 빠르게 작성하고 유지하는데 얼마나 많은 도움이 되는지 알기 어렵다.

다음에 나오는 예제에서 벡터 인스턴스 사이에 있는 요소를 어떻게 제거하는지 살펴보자. 벡터에서 특정 요소가 사라져 다른 요소 사이에 빈값이 위치하게 될 경우 원래 자리의 오른쪽에 위치했던 모든 요소들은 왼쪽으로 하나씩 이동한다. 그리고 해당 작업 때문에 O(n) 시간으로 실시간 비용이 발생한다. 많은 초보 프로그래머는 이때 가장 쉬운 방법인 반목문을 이용할 것이다. 그러나 안타깝게도 이 방법을 사용하면 숨어있는 최적화 기능을 대부분 무시하게 된다. 그리고 직접 만든 반복문은 STL 방식보다 깔끔하지도 않다는 것을 바로 다음에 나올 부분에서 확인하게 될 것이다.

### 예제 구현

이번 예제에서는 std::vector 인스턴스에 정수를 채워 넣은 후 특정 요소를 없앨 것이다. 여기서 하는 방법은 벡터에서 두 개 이상의 요소를 제거하는 가장 올바른 방법이다.


1. 시작하기 전에 가장 먼저 헤더 파일을 포함시킨다.

``` c++
#include <iostream>
#include <vector>
#include <algorithm>
```


2. 그런 다음 나중에 코드 입력을 줄이기 위해 std 네임스페이스의 사용을 선언한다.

``` c++

using namespace std;
```

3. 이제 정수 벡터를 생성해 요소들을 채워 넣는다.
``` c++

int main(){

  vector<int> v {1, 2, 3, 2, 5, 2, 6, 2, 4, 8};
```


4. 다음 단계는 해당 요소를 제거하는 과정이다. 어떤 요소를 제거할까? 이 코드에는 2 값이 두 개 이상 있다. 해당 값을 지워보자.
``` c++
        const auto new_end (remove(begin(v), end(v), 2));
```


5. 재밌는 것은 아직 한 단계가 더 남았다는 것이다. 벡터의 크기는 여전히 같다. 다음 줄은 벡터를 더 작게 만든다.
``` c++
v.erase(remove_if(begin(v),end(v),odd),end(v));
```

6. 여기까지 하고 벡터의 내용물을 터미널로 출력한 후 다음으로 넘어가자.

``` c++

    for (auto i : v) {
        cout << i << ", ";
    }

    cout << '\n';
```



7. 이제 특정 값 대신 분류된 모든 요소를 제거해보자. 이 작업을 위해선 프레디케이트(predicate) 함수를 먼저 정의한다. 해당 함수는 하나의 숫자를 파라미터로 받고, 이 숫자가 홀수면 true를 반환한다.

``` c++
        const auto odd ([](int i) { return i % 2 != 0; });
```

8. 이제 remove_if 함수를 이용해 이를 프레디케이트 함수로 전달한다. 이렇게 하면 앞에서처럼 두 단계를 거치지 않고 한 번에 제거할 수 있다.

``` c++
        const auto new_end (remove_if(begin(v), end(v), odd));
```


9. 이제 홀수가 전부 제거되었으나 벡터의 용량은 아직도 10이다. 마지막 단계로 벡터의 실제 현재 크기로 줄여보자. 해당 벡터 코드는 크기에 맞게 신규 메모리 영역을 할당하고, 모든 요소를 신규 메모리 영역으로 옮긴다는 점을 기억하자.

``` c++
    v.shrink_to_fit();
```


10. 이제 두 번째 제거 이후 내용물을 출력하면 끝이다.

``` c++
    for (auto i : v) {

        cout << i << ", ";

    }

    cout << '\n';
```

11. 프로그램을 컴파일하고 실행시키면 요소를 제거하면 두 가지 접근법을 통해 다음과 같이 출력된다.


``` c++
PS C:\C-language\cpp_STL\Chapter02> ./Chapter02_1
1, 3, 5, 6, 4, 8,
6, 4, 8,
```



---
### 예제 분석

이번 예제에서 알게 된 한 가지가 있다. 벡터 한중간에서 요소를 제거할 때 제거를 먼저 한 다음에 삭제를 해줘야 한다는 점이다. 최소한 지금까지 사용한 함수는 그렇게 했었다. 좀 헷갈리는 방식인 건 사실이지만, 이러한 과정이 왜 필요한지 자세히 들여다보면 이해가 갈 것이다.


벡터로부터 모든 2 값을 제거하는 코드는 다음과 같이 보인다.


``` C++
    const auto new_end (remove_if(begin(v), end(v), odd));

        v.erase(new_end, end(v));
```


std::begin과 std::end 함수 둘 다 파라미터로 벡터 인스턴스를 받으며 반복자를 반환하는데, 이 반복자는 다음에 나올 다이어그램과 같이 가장 처음 요소와 마지막 요소 다음을 가리킨다.


이와 함께 2 값을 std::remove 함수로 넘겨주면 2가 아닌 나머지 값을 앞으로 옮긴다. 즉, 반복문을 직접 짜는 것과 같다. 이를 위해 해당 알고리즘이 2가 아닌 값들의 순서를 엄격하게 보존한다. 다이어그램을 얼핏 보면 다소 헷갈릴 수도 있다. 두 번째 단계로 넘어가 보자. 그런데 벡터가 아직 줄지 않았을 뿐더러 제거됐어야 할 네 개의 2 값 중 한 개가 남아있는 것이 보일 것이다. 그리고 최초의 배열에 있던 4와 8이 중복되 있다. 이건 뭘까?


[그림]


이 다이어그램에서 begin 반복자와 new_end 반복자 사이에 있는 요소만 보자. new_end 반복자가 가리키는 요소는 범위를 벗어난 첫 번재 요소이므로 포함되지 않는다. 해당 범위, 즉 1에서 8까지만 보면 이것이 곧 최초 배열에서 2만 제거한 올바른 범위라는 것을 알 수 있다.

여기서 erase 호출을 사용한다. 해당 벡터에서 이제는 new_end에서 end까지 전체가 벡터 요소가 아니라는 것을 알려줘야 한다. 이 과정은 매우 쉽다. 그냥 end 반복자로 new_ned의 위치를 가리키면 된다. 여기서 new_end는 std::remove 호출의 반환값이므로, 이를 사용할 수 있다.


>[!info]
>그냥 내부 포인터를 이동시키는 것보다 해당 벡터를 이용하는 것이 훨씬 더 효과적이라는 점에 주목하자. 좀 더 복잡한 객체의 벡터였다면 제거될 모든 요소의 소멸자를 호출했을 것이다.


여기까지 처리하고 나면 벡터가 앞의 다이어그램에서 3번 단계와 같이 더 줄어든 모습이 된다. ==현재 범위 밖에 있는 기존 요소들은 아직 메모리에 남아있다.==

해당 벡터가 필요한 만큼만 메모리를 차지하게 하기 위해 마지막에 shrink_to_fit를 호출한다. 그러면 정확히 필요한 메모리만 할당하고 전체 요소를 이동시켜 이제는 필요 없는 큰 메모리 영역을 삭제한다.

8단계에서는 프리디케이트 함수를 정의하고 std::remove_if와 함께 사용했다. 이 방법이 유용한 이유는 제거 함수가 어떤 반복자를 반환하든 벡터의 삭제 함수 내에서 사용할 때 매우 안전하기 때문이다. 설령 홀수 요소가 발견되지 않더라도 std::remove_if 함수는 아무것도 하지 않고 end 반복자를 반환할 것이다. 또한 이에 따라 v.erase(end,end);와 같은 호출도 아무것도 하지 않으므로 전혀 해가 없다.

---

### 부연 설명


std::remove 함수를 다른 컨테이너에도 사용할 수 있다. ==std::array와 함께 사용하면 자동 크기 조절 기능이 없기 때문에 erase 호출을 사용하는 두 번째 과정이 지원되지 않는다는 점을 기억하자.== std::remove가 효율적으로 주변의 요소들을 옮기기는 하지만 실질적으로 삭제를 하는 것은 아니므로, 크기 조정을 지원하지 않는 배열 같은 데이터 구조체에도 사용할 수 있다. 예를 들어 배열을 사용하는 경우 새로운 end 반복자 다음에 나오는 값을 '\0' 같은 경계 값으로 겹쳐 쓸 수 있다.


---
- [[STL 컨테이너]]
- [[O(1) 시간으로 정렬되지 않은 std__vector의 요소 삭제]]
- 